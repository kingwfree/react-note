<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>基本语法</title>
    <style>
        .red{
            color:red;
        }
    </style>
</head>
<body>
    <div id="app"></div>
    <div class="test"></div>
    <div class="test"></div>
    <div class="test1"></div>
    <div class="test1"></div>
    <div class="test1"></div>
    <div class="test1"></div>
    <div class="test1"></div>
    <hr>
    <div class="test2"></div>
    <div class="test2"></div>
    <hr>
    <div class="test3"></div>
    <div class="test3"></div>
    <div class="test3"></div>
    <hr>
    <div class="test4"></div>
    <hr>
    <div class="test5"></div>
    <div class="test5"></div>
    <hr>
    <div class="test6"></div>
    <hr>
    <div class="test7"></div>
    <hr>
    <div class="test8"></div>



    <script src="./node_modules/react/umd/react.development.js"></script>
    <script src="./node_modules/babel-standalone/babel.js"></script>
    <script src="./node_modules/react-dom/umd/react-dom.development.js"></script>
    
    <script type="text/babel">
    /*
        class -> className
        style -> style={object}
        value -> defaultValue
        单标签要闭合
        for -> htmlFor
        focus -> autoFocus
    */

    //js里写html代码 jsx语法
        //写react语法 需要babel解析
        //react 只关注ui层
        //react-dom 只处理dom 用户交互
        //console.log(ReactDOM)
        //render: ƒ (element, container, callback)
        ReactDOM.render(
            <h1>Hello World</h1>,//只能有一个父容器，其他容器必须被包裹
            document.querySelector('#app')
        )
        ReactDOM.render(
            <h1>Hello World12</h1>,//只能有一个父容器，其他容器必须被包裹
            document.querySelector('#app')
        )
        //当要render的容器是同一个时，其他的会被覆盖，只会显示最后一个
        const ele = <div>
            这是父节点
            <p>
                这是子节点
                
            </p>    
        </div>;
        ReactDOM.render(
            ele,
            document.querySelector('#app')
        )
        //注释
        const ele1 = <div>
            这是父节点
            <p>
                这是子节点
            </p>   
            <div>
                
                //js注释
                {
                    //插值符号
                    
                    '这是插值内容'
                    //这里可以写js注释
                    /*
                        这是多行注释
                    */
                    //这是单行注释
                    
                }
                
            </div> 
        </div>;
        
        // ReactDOM.render(
        //     ele1,
        //     document.querySelector('.test')
        // )
        //console.log(document.querySelector('.test'))
        //当使用document.querySelector获取元素class时只获取第一个
        ReactDOM.render(
            ele1,
            document.getElementsByClassName('test')[1]
        )
        //根据数据生成结构
        //return 后面的代码要写在（）里，作为一个整体
        //函数里写js代码
        //class是一个关键词
        function createJSX() {
            return (
                <div className="red">
                    函数里返回标签
                    //js注释
                    {
                        //插值符号
                        
                        '这是插值内容'
                        //这里可以写js注释
                        /*
                            这是多行注释
                        */
                        //这是单行注释
                        
                    } 
                </div>
            )
        }
        const ele2 = createJSX();
        ReactDOM.render(
            ele2,
            document.getElementsByClassName('test')[1]
        )
    </script>

    <!-- 插值符号 -->
    <script type="text/babel">
        //插值符号
        //{} ->数字 布尔 字符串 表达式 即时函数 数组
        const person = {
            name:'zf',
            sex:1
        };
        const ele = (
            <div>
                <h1>Hello</h1>
                {
                    //插值符号里写js代码
                }
                <p>my name is {person.name}</p>    
            </div>
        );
        ReactDOM.render(
            ele,
            document.getElementsByClassName('test1')[0]
        );
        //arr 通过axios fetch请求后端
        const arr = ['傻子飞','哈士奇','黑煞','老狗'];
        const ele1 = (
            <ul>
                {
                    //在jsx里用插值符号插入数据
                    arr.length > 0 && arr.map((item,index)=>{
                        return (
                            <li 
                                key={index}>
                                {item}
                            </li>
                        )
                    })
                }    
            </ul>
        );
        ReactDOM.render(
            ele1,
            document.getElementsByClassName('test1')[0]
        );
        //在插值符号里使用三目表达式进行判断  不能使用if只能写表达式
        const ele2 = (
            <p>
                性别：
                {
                    person.sex ? '男':'女'
                }
            </p>
        )
        ReactDOM.render(
            ele2,
            document.getElementsByClassName('test1')[1]
        );
        //在插值符号里写自执行函数
        const ele3 = (
            <div>
                {
                    (function () {
                        if(person.sex)return <p>男</p>

                        return <p>女</p>
                    })()
                }    
            </div>
        );
        ReactDOM.render(
            ele3,
            document.getElementsByClassName('test1')[2]
        );
        //调用函数
        function getSex() {
            if(person.sex)return <p>男</p>

            return <p>女</p>
        }
        ReactDOM.render(
            <div>
                {
                    getSex()
                }
            </div>,
            document.getElementsByClassName('test1')[4]
        )
        //插值符号会把数组直接展开
        const ele4 = (
            <div>
                {
                    //数组能自动展开
                    //arr
                    //对象不能自动展开
                    //person

                    //Object.keys(person)
                }
            </div>
        );
        ReactDOM.render(
            ele4,
            document.getElementsByClassName('test1')[3]
        );
        //样式
        const styles = {
            title:{
                background:'blue',
                color:'yellow'
            },
            content:{
                fontSize:'50px',
                color:'skyblue'
            }
        };
        const ele5 = (
            <div style={styles.title}>
                样式
                <div style={{color:'red'}}>
                    hasky
                </div>
            </div>
        );
        ReactDOM.render(
            ele5,
            document.getElementsByClassName('test2')[0]
        );
    </script>

    <!-- 事件绑定 -->
    <script type="text/babel">
        //事件绑定
        //call 立马执行 
        //bind 不会立马执行 预传参 参数在函数执行时才传递
        //函数最后一个参数是事件对象event
        function handleClick(data,event) {
            alert('事件调用函数')
            console.log(data,event.target)
        }
        function handleKeyDown(e) { 
            console.log('keydown',e)
        }
        
        const ele = (
            <div>
                <p>事件处理</p>
                <input 
                    type="button" 
                    value='自执行' 
                    onClick={alert('自执行,只执行一次')} 
                />
                <br />
                <input 
                    type="button" 
                    value='箭头函数' 
                    onClick={()=>{alert('箭头函数')}} 
                />
                <br />
                <input 
                    type="button" 
                    value='事件调用函数' 
                    onClick={ handleClick.bind(this,'这才是参数') } 
                />
                <br />
                <input 
                    type="text" 
                    defaultValue='keydown' 
                    onKeyDown={ handleKeyDown } 
                />
            </div>
        );
        ReactDOM.render(
            ele,
            document.getElementsByClassName('test2')[1]
        );
        
    </script>

    <!-- 组件 -->
    <script type="text/babel">
        //区分是否是组件  看是否有状态
        //什么是状态
        //让数据驱动视图的响应式数据
        //状态 = 数据
        //state 用于数据管理
        //但是一个项目有太多的页面，而页面与页面间需要数据互联
        //这时需要一个js库帮我们去管理，方便在每一个页面 都是拿到最新的数据
        //redux js库 能帮我们管理大量的数据
        //想要在每个页面都能很方便的去调取redux里面的数据，使用react-redux模块（js库）
        
        //这是无状态的
        //2秒过去后，它并不会更新组件 ，这不是一个响应式数据
        let str = 'dream';
        const ele = (
            <div>
                {str}
            </div>
        )
        ReactDOM.render(
            ele,
            document.getElementsByClassName('test3')[0]
        )

        setTimeout(() => {
            str = "zfq"
        }, 2000);

        //声明一个函数组件
        //无状态的
        function Head(){
            return (
                <header>这是页面头部</header>
            )
        }
        function Main() {
            return (
                <main>这是页面主体内容</main>
            )
        }
        function Foot() {
            return (
                <footer>这是页面底部</footer>
            )
        }
        const ele1 = (
            <div>
                <Head></Head>
                <Main></Main>
                <Foot />
            </div>
        )
        ReactDOM.render(
            ele1,
            document.getElementsByClassName('test3')[1]
        )
        //有状态组件
        //定义Head组件 继承自React的 component组件
        //那么就可以去调用React的component组件所提供的方法和属性
        /*
            state  状态  负责页面的视图的数据
            props  属性  传递属性
        */
        class Div extends React.Component{
            constructor(props){
                super(...arguments);
                this.name = 'dream'
                this.age = 18
                console.log(props);
                this.state = {
                    abc:this.props.text
                }
                this.handleClick = this.handleClick.bind(this)
                setTimeout(()=>{
                    this.setState({
                        abc:'123'
                    })
                },2000)
            }
            //不要写function
            say(){
                console.log('方法')
            }
            //在这里定义对象也会被挂载到实例对象上 在原本的es6语法里是不行的
            xyz = {}
            handleClick(){
                //console.log(this); //没bind undefined
                //this.state.abc = '点击改变'
                this.setState({
                    abc:'点击改变'
                })
            }
            handleClick1(){
                console.log(this)
            }
            handleClick3 = ()=>{
                console.log(this)
            }
            handleClick2(e){
                console.log(this,e)
            }
            render(){
                return (
                    
                    <div
                        onClick={this.handleClick}
                    >
                        {
                        /*
                        
                            第一种方式不适合传参
                            第二种方式适合传参
                            第四种方法也可以传参
                            
                            
                        */
                        }
                        { this.state.abc && this.state.abc }
                        <input type="button" onClick={this.handleClick1.bind(this)}/>
                        <input type="button" onClick={this.handleClick3}/>
                        <input type="button" onClick={(e)=>{this.handleClick2(e)}}/>
                    </div>
                )
            }
        }

        ReactDOM.render(
            <Div 
                title="首页"
                text="这是有状态组件!"
            />,
            document.getElementsByClassName('test3')[2]
        )
        
    </script>

    <!-- import -->
    <script type="module">
        import ab,{getData,title,arr,obj} from './es6.js'

        console.log(ab,getData,title,arr,obj)
    </script>

    <script type="text/babel">
        //for -> htmlFor
        //focus -> autoFocus
        const ele = (
            <div>
                1312
                <input id={'txt'} type='text' autoFocus />  
                <label htmlFor='txt'>132132</label>
            </div>
        )
        ReactDOM.render(
            ele,
            document.getElementsByClassName('test4')[0]
        )
    </script>

    <!-- 获取DOM节点 -->
    <script type="text/babel">
        class Ele extends React.Component{

            handleClick(e) {
                //通过 元素选择器获取DOM
                const ipt = document.getElementsByTagName('input')
                console.log(ipt)
                //通过 事件对象获取DOM
                const {target} = e
                console.log(target)
                //通过ref属性操作dom
                console.log(this.refs.btn)
                ReactDOM.findDOMNode(target).style.background="red"
            }
            render(){
                return (
                    <div>
                        Dom
                        <input 
                            ref="btn"
                            type="button"
                            defaultValue="操作DOM"
                            onClick={this.handleClick.bind(this)}
                        />
                    </div>
                )
            }
        }
        ReactDOM.render(
            <Ele />,
            document.getElementsByClassName('test5')[1]
        )
    </script>

    <!-- refs -->
    <script type="text/babel">
        /*
            虚拟DOM
            只有当它插入文档以后，才会变成真实的DOM
            可以从ref属性获取真实dom
        */
        class List extends React.Component{
            render(){
                return (
                    <div>
                        <p>list组件</p>
                    </div>
                )
            }
        }
        /*
            新版本react不推荐使用ref string 推荐使用 ref callback
            ref callback -> this.属性名
            被点击的input标签被挂载到了实例对象下
        */
        class Ele extends React.Component{
            handleClick=()=>{
                console.log(this)
                const _div = this._div;
                ReactDOM.findDOMNode(_div).style.background="blue"
            }
            render(){
                return (
                    <div>
                        <input 
                            ref = {item=>this._div = item}
                            type="button"
                            onClick={
                                ()=>{
                                    this.handleClick()
                                    console.log(this)
                                    //传入组件
                                    /*
                                        当把一个实例化对象传入ReactDOM.findDOMNode，
                                        ReactDOM.findDOMNode会返回这个实例化对象中的render里的内容
                                    */
                                    console.log(ReactDOM.findDOMNode(this._list),this._list)
                                    console.log(ReactDOM.findDOMNode(this._list) == this._list)
                                    //false
                                    //传入元素
                                    /*
                                        当把一个元素传入ReactDOM.findDOMNode，
                                        ReactDOM.findDOMNode，会返回这个元素节点
                                    */
                                    console.log(ReactDOM.findDOMNode(this._div) == this._div)
                                    //true
                                }
                            }
                        />
                        {
                            //将组件的实例化对象挂载到当前的实例化对象上
                        }
                        <List 
                            ref={item=>this._list=item}
                        />
                    </div>
                )
            }
        }
        ReactDOM.render(
            <Ele />,
            document.getElementsByClassName('test6')[0]
        )
    </script>

    <!-- 组件与父子组件通讯 -->
    <script type="text/babel">
        class List extends React.Component{
            // constructor(props){
            //     super(props)
            //     console.log(this.props.value)
            // }
            render(){
                console.log(this.props)
                return (
                    <div>
                        <p>list组件 子</p>
                        {this.props.value}
                        {
                            //子组件调用父组件的方法
                            //子组件向父组件传参
                        }
                        <input 
                            type="button"
                            onClick={this.props.fn.bind(this,'传参')}
                        />
                    </div>
                )
            }
        }
        class Ele extends React.Component{
            state={
                data:'父组件的数据'
            }
            getData(a){
                console.log('父组件的getData函数',a)
            }
            render(){
                return (
                    <div>
                        <p>ele组件 父</p>
                        {
                            //父组件向子组件传递信息
                        }
                        <List 
                            value={this.state.data}
                            fn={this.getData}
                        />
                    </div>
                )
            }
        }
        ReactDOM.render(
            <Ele />,
            document.getElementsByClassName('test7')[0]
        )
    </script>

    
</body>
</html>